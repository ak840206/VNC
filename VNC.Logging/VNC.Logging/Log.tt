<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//'------------------------------------------------------------------------------------------------------------------------
//'
//' TODO: Determine how to use the TraceEventType enumeration.  Vista seems to have more levels.  Windows 2003 fewer.  
//'       Should probably plan for future. Review the mapping levels
//'       Not sure how to get Critical messages to appear in eventlog.  Go look in EntLib code to see if they do mapping.
//'
//'       TraceEventType  Description                         Value   Vista Log   2003 Log    2008 Log    Log Method	    Priority Filter
//'       --------------  ---------------------------------   -----   ---------   --------    --------    ------------		---------------
//'       Critical        Fatal error or application crash    1       Error       ?           ?           Failure			Log.Failure		(-10)
//'       Error           Recoverable error                   2       Error                               Error				Log.Error		(-1)
//'       Warning         Non-Critical Problem                4       Warning                             Warning			Log.Warning		(1)       
//'       Information     Informational message               8       Information Information ?           Info				Log.Info		(100)
<#
	int infoLevels = 5;
	int debugLevels = 5;
	int traceLevels = 30;

	for (int i = 1 ; i <= infoLevels ; i++)
	{
#>
//'																										  Info<#= i #>				Log.Info<#= i #>		(10<#= i #>)
<#
	}
#>
//'       Verbose         Debugging trace                     16                                          Debug				Log.Debug		(1000)
<#
	for (int i = 1 ; i <= debugLevels ; i++)
	{
#>
//'																										  Debug<#= i #>			Log.Debug<#= i #>		(100<#= i #>)
<#
	}
#>
//'                                                                                                       Trace				Log.Trace       (10000)
<#
	for (int i = 1 ; i <= traceLevels ; i++)
	{
#>
//'                                                                                                       Trace<#= i #>			Log.Trace<#= i #>		(1000<#= i #>)
<#
	}
#>
//'
//'       Start          Starting of logical operation        256
//'       Stop           Stopping of logical operation        512
//'       Suspend        Suspension of logical operation      1024
//'       Resume         Resumption of logical operation      2048
//'       Transfer       Changing of correlation identity     4096
//'
//' TO DECIDE:
//'   I don't think we need the methods that don't pass a applicationCategory.  I also think we might want to skip the Info, Debug, and Trace
//'   versions that take a stacktrace flag.
//'   That would leave two versions for Failure and Error and one each for Warning, Info, Debug, and Trace.
//'
//' NOTES:
//'   The methods use the
//'           <System.Diagnostics.DebuggerStepThrough()> _
//'   attribute to suppress tracing through the logging code.  You can still set breakpoints in the method if you want.
//'
//'------------------------------------------------------------------------------------------------------------------------

//''' <summary>
//''' 
//''' </summary>
//''' <remarks>Wrapper around EnterpriseLibrary.Logging.Logger.Write  Simplifies calling by setting values for Priority and Severity.  Passes several extended properties.</remarks>

/// <summary>
/// Low level routines used by client and web applications
/// 
/// </summary>
namespace VNC
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Reflection;

    using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;
    using Microsoft.Practices.EnterpriseLibrary.Logging;

    [Serializable]
    public partial class Log
    {
        private const long NoElapsedTime = 0L;

        public enum LoggingPriority : int
        {
			// Some priorities have been used consistently and are named for easier use.
			// Keep this in sync with LogNamed.tt named_methods

			APPLICATION_START = 100,
			APPLICATION_END = 100,
			LOADEASE = 100,

			SQL_CALL = 1002,

			PAGE_LOAD = 10000,
			FORM_LOAD = 10000,

			EVENT_HANDLER = 10001,
            EVENT = 10021,

			STATUS = 10002,
            APPLICATION_INITIALIZE = 10002,

			REDIRECT_TRANSFER = 10003,

			POLLING = 10004,

			ERROR_TRACE = 10005,
			ERROR_TRACE_LOW = 10015,

			EASESYS_IO = 10006,
			EASESYS_IO_MED = 10016,
			EASESYS_IO_LOW = 10026,
            INFRASTRUCTURE = 10016,

			UI_CONTROL = 10007,
			UI_CONTROL_MED = 10017,
			UI_CONTROL_LOW = 10027,

            PRESENTATION = 10007,
            VIEW = 10017,
            VIEW_LOW = 10027,

			UTILITY = 10008,
			UTILITY_MED = 10018,
			UTILITY_LOW = 10028,
            VIEWMODEL = 10018,
            VIEWMODEL_LOW = 10028,

			OPERATION = 10009,
			OPERATION_LOW = 10019,
            CORE = 10009,
            MODULE = 10019,
            MODULE_INITIALIZE = 10029,

			APPLICATION_SESSION = 10010,
			APPLICATION_SESSION_LOW = 10020,

            APPLICATION = 10010,
            APPLICATIONSERVICES = 10020,

			SYSTEM_CONFIG = 10011,
			SYSTEM_CONFIG_LOW = 10021,

			FILE_DIR_IO = 10012,
			FILE_DIR_IO_LOW = 10022,

            DOMAIN = 10012,
            DOMAINSERVICES = 10022,

			DATABASE_IO = 10013,
			DATABASE_IO_LOW = 10023,

            PERSISTENCE = 10013,
            PERSISTENCE_LOW = 10023,

			SECURITY = 10014,
			SECURITY_LOW = 10024,

			DEFAULT = 10019,

			CLEAR_INITIALIZE = 10025,
            CONSTRUCTOR = 10025,

			// Below are the standard levels

            Failure		= -10,
            Error		= -1,
            Warning		= 1,
            Info		= 100,
<#
	for (int i = 1 ; i <= infoLevels ; i++)
	{
#>
			Info<#= i #>		= 10<#= i #>,
<#
	}
#>
            Debug		= 1000,
<#
	for (int i = 1 ; i <= debugLevels ; i++)
	{
#>
			Debug<#= i #>		= 100<#= i #>,
<#
	}
#>
            Trace		= 10000,
<#
	for (int i = 1 ; i <= traceLevels ; i++)
	{
		if (i < 10)
		{ 
			WriteLine(string.Format("\t\t\tTrace{0}\t\t= 1000{1},", i, i));
		}
		else
		{ 
			WriteLine(string.Format("\t\t\tTrace{0}\t\t= 100{1},", i, i));
		}
	}
#>
			Max			= 100<#= traceLevels #>
        }

        public enum ShowStack
        {
            No,
            Yes
        }

        static Log()
        {
            IConfigurationSource configurationSource = ConfigurationSourceFactory.Create();
            LogWriterFactory logWriterFactory = new LogWriterFactory(configurationSource);
            Logger.SetLogWriter(logWriterFactory.Create());
        }

    #region Public Write Methods

        [DebuggerStepThrough]
        public static void Write(Exception ex, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, bool showStack)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category == "")
            {
                category = "General";
            }
            InternalWrite(ex.Message + ex.StackTrace, severity, category, priority, className, methodName, name, showStack);
        }

        [DebuggerStepThrough]
        public static void Write(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, bool showStack)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category == "")
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, name, showStack);
        }

        [DebuggerStepThrough]
        public static void Write(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, bool showStack, long startTicks)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category == "")
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, name, showStack, startTicks);
        }

        [DebuggerStepThrough]
        public static void WriteLight(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, bool showStack, long startTicks)
        {
            if (category == "")
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, "<unknown>", showStack, startTicks);
        }

    #endregion

    #region Private Write Methods

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, int EventId)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, long startTicks)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, Dictionary<string, string> extendedProp)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, int EventId, long startTicks)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, int EventId, Dictionary<string, string> extendedProp)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, long startTicks, Dictionary<string, string> extendedProp)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, string className, string methodName, string callingAssemblyName, bool showStack, int EventId, long startTicks, Dictionary<string, string> extendedProp)
        {
            string str = "";
            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }


            LogEntry log = new LogEntry();
            if (category == "")
            {
                category = "General";
            }
            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }
            log.Message = message;
            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

		// This is new in EASE
		// Think it might be an alternative to the Log() constructor

		//private static LogWriter InternalWriter()
        //{
		//	//Internal Writer allows callers to just log without any configuration from the calling assembly
		//	//This also allows us to wrap tests around this class.
		//
        //    string loggingConfigSetting = Properties.Resources.LoggingConfiguration;
		//
        //    string tempConfigPath = System.IO.Path.GetTempFileName();
        //    System.IO.File.AppendAllText(tempConfigPath, loggingConfigSetting);
		//
        //    Microsoft.Practices.EnterpriseLibrary.Common.Configuration.FileConfigurationSource configSource = new Microsoft.Practices.EnterpriseLibrary.Common.Configuration.FileConfigurationSource(tempConfigPath);
        //    LogWriterFactory logFactory = new LogWriterFactory(configSource);
        //    return logFactory.Create();
        //}

    #endregion

    #region Log Failure Methods

        [DebuggerStepThrough]
        public static void Failure(Exception ex, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true);
        }

        [DebuggerStepThrough]
        public static void Failure(Exception ex, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, props);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
        }

        [DebuggerStepThrough]
        public static void Failure(Exception ex, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory, bool showStack)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
        }

        [DebuggerStepThrough]
        public static void Failure(Exception ex, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId, props);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory, bool showStack, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack, props);
        }

        [DebuggerStepThrough]
        public static void Failure(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Critical, applicationCategory, LoggingPriority.Failure, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
        }

    #endregion

    #region Log Error Methods

        [DebuggerStepThrough]
        public static void Error(Exception ex, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
        }

        [DebuggerStepThrough]
        public static void Error(Exception ex, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId);
        }

        [DebuggerStepThrough]
        public static void Error(Exception ex, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, props);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory, bool showStack)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
        }

        [DebuggerStepThrough]
        public static void Error(Exception ex, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId, props);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory, bool showStack, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack, props);
        }

        [DebuggerStepThrough]
        public static void Error(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Error, applicationCategory, LoggingPriority.Error, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
        }

    #endregion

    #region Log Warning Methods

        [DebuggerStepThrough]
        public static void Warning(Exception ex, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
        }

        [DebuggerStepThrough]
        public static void Warning(Exception ex, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId);
        }

        [DebuggerStepThrough]
        public static void Warning(Exception ex, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, props);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory, bool showStack)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
        }

        [DebuggerStepThrough]
        public static void Warning(Exception ex, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(1), EventId, props);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory, bool showStack, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack, props);
        }

        [DebuggerStepThrough]
        public static void Warning(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Warning, applicationCategory, LoggingPriority.Warning, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
        }

    #endregion

    #region Log Info Methods

<#
	string level = "";

	for (int i = 0 ; i <= infoLevels ; i++)
	{
		if (i > 0) level = i.ToString();
#>
		#region Info<#= level #>

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, long startTicks, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, int EventId, long startTicks)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Info<#= level #>(string message, string applicationCategory, int EventId, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.Info<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks, props);
            return Stopwatch.GetTimestamp();
        }

		#endregion
<#
	}
#>
	#endregion

    #region Log Debug Methods

<#
	level = "";

	for (int i = 0 ; i <= debugLevels ; i++)
	{
		if (i > 0) level = i.ToString();
#>	
		#region Debug<#= level #>

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, long startTicks, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, int EventId, long startTicks)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Debug<#= level #>(string message, string applicationCategory, int EventId, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Debug<#= level #>, 
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks, props);
            return Stopwatch.GetTimestamp();
        }

		#endregion
<#
	}
#>

#endregion

	#region Trace Log Methods

<#
	level = "";

	for (int i = 0 ; i <= traceLevels ; i++)
	{
		if (i > 0) level = i.ToString();
#>
		#region Trace<#= level #>

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, int EventId)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, long startTicks, MethodBase method = null)
        {
            //StackTrace trace = new StackTrace();
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, int EventId, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, int EventId, long startTicks)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), startTicks, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long Trace<#= level #>(string message, string applicationCategory, int EventId, long startTicks, Dictionary<string, string> props)
        {
            //StackTrace trace = new StackTrace();
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Verbose, applicationCategory, LoggingPriority.Trace<#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, Convert.ToBoolean(0), EventId, startTicks, props);
            return Stopwatch.GetTimestamp();
        }

        #endregion



<#
	}
#>

	#endregion

    public static double GetDuration(long startTicks)
    {
        return (double)(Stopwatch.GetTimestamp() - startTicks) / ((double)Stopwatch.Frequency);
    }

    public static double GetDuration(long startTicks, long endTicks)
    {
        return (double)(endTicks - startTicks) / ((double)Stopwatch.Frequency);
    }

    // TODO(crhodes)
    // Dojie put this as an nested class.  Might want to pull out and put above.  Go see how these are used.

	#region Helper Class

        public static class Helpers
        {
            [DebuggerStepThrough]
            public static T ExecuteLogHandledOp<T>(Func<T> action, Log.LoggingPriority loggingPriority, string applicationCategory, string additionalStartMessage = null, string additionalEndMessage = null)
            {
                //StackTrace trace = new StackTrace();
                MethodBase method = new StackFrame(1).GetMethod();
                var startMethod = typeof(Log).GetMethod(loggingPriority.ToString(), new Type[] { typeof(string), typeof(string), typeof(MethodBase) });
                long dbTicks = 0;
                if (startMethod != null)
                {
				    try
                    {
						dbTicks = (long)startMethod.Invoke(null, new object[] { string.Format("Enter: {0}", additionalStartMessage), applicationCategory, method });                   
                    }
                    catch (Exception ex)
                    {
						Log.Error(string.Format("Exception: {0}", additionalStartMessage), applicationCategory);
                        Log.Error(ex, applicationCategory);
                    }
                }

                var result = action();

                var endMethod = typeof(Log).GetMethod(loggingPriority.ToString(), new Type[] { typeof(string), typeof(string), typeof(long), typeof(MethodBase) });
                if (endMethod != null)
                {
				    try
                    {
						endMethod.Invoke(null, new object[] { string.Format("Exit: result:({0}) {1}", result, additionalEndMessage), applicationCategory, dbTicks, method });                                    
                    }
                    catch (Exception ex)
                    {
						Log.Error(string.Format("Exception: {0}", additionalEndMessage), applicationCategory);
                        Log.Error(ex, applicationCategory);
                    }
                }

                return result;
            }

			[DebuggerStepThrough]
            public static void ExecuteLogHandledOp(Action action, Log.LoggingPriority loggingPriority, string applicationCategory, string additionalStartMessage = null, string additionalEndMessage = null)
            {
                //StackTrace trace = new StackTrace();
                MethodBase method = new StackFrame(1).GetMethod();
                var startMethod = typeof(Log).GetMethod(loggingPriority.ToString(), new Type[] { typeof(string), typeof(string), typeof(MethodBase) });
                long dbTicks = 0;
                if (startMethod != null)
                {
                    try
                    {
						dbTicks = (long)startMethod.Invoke(null, new object[] { string.Format("Enter: {0}", additionalStartMessage), applicationCategory, method });                                   
                    }
                    catch (Exception ex)
                    {
                        Log.Error(string.Format("Exception: {0}", additionalStartMessage), applicationCategory);
						Log.Error(ex, applicationCategory);
                    }
				}

                action();

                var endMethod = typeof(Log).GetMethod(loggingPriority.ToString(), new Type[] { typeof(string), typeof(string), typeof(long), typeof(MethodBase) });
                if (endMethod != null)
                {
					try
                    {
						endMethod.Invoke(null, new object[] { string.Format("Exit: {0}", additionalEndMessage), applicationCategory, dbTicks, method });
				    }
                    catch (Exception ex)
                    {
						Log.Error(string.Format("Exception: {0}", additionalEndMessage), applicationCategory);
						Log.Error(ex, applicationCategory);
					}
				}
            }


        }

        #endregion 

    }
}